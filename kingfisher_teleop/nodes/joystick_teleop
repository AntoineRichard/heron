#!/usr/bin/python

import roslib; roslib.load_manifest('kingfisher_teleop')
import rospy

from sensor_msgs.msg import Joy, Imu
from geometry_msgs.msg import Twist, Wrench
from kingfisher_msgs.msg import Course, Helm
from tf.transformations import euler_from_quaternion


class Teleop:
    def __init__(self):
        rospy.init_node('clearpath_teleop')

        self.rotation_scale = rospy.get_param('~rotation_scale',0.5) #rad/s

        bck_force_scale = rospy.get_param('~bck_force_scale', 40) #Newtons
        self.button_scales = {
            "deadman": {
                "fwd_vel": rospy.get_param('~fwd_vel_scale', 5), #m/s
                "bck_vel": rospy.get_param('~bck_vel_scale', 0.5), #m/s
                "fwd_force": rospy.get_param('~fwd_force_scale', 75), #Newtons
                "bck_force": bck_force_scale
            },
            "turbo": {
                "fwd_vel": rospy.get_param('~tb_fwd_vel_scale', 2.5), #m/s
                "bck_vel": rospy.get_param('~tb_bck_vel_scale', 0.5), #m/s
                "fwd_force": rospy.get_param('~tb_fwd_force_scale', 75), #Newtons
                "bck_force": rospy.get_param('~tb_bck_force_scale', 40) #Newtons
            }
        }

        self.boat_width = 0.381
        self.torque_scale = rospy.get_param('~torque_scale', bck_force_scale * 2 * self.boat_width) #N.m, max torque depends on max reverse thrust possible
         
        self.deadman_button = rospy.get_param('~deadman_button', 0)
        self.turbo_button = rospy.get_param('~turbo_button', 1)
        self.heading_hold_button = rospy.get_param('~heading_hold_button',3)
        self.autonomous_button = rospy.get_param('~autonomous_button',2)

        self.autonomous = False
        self.last_auto_button = 0

        self.heading_hold = False
        self.curr_heading=0
        self.hold_heading = 0
        self.last_heading_button = 0

        self.max_age = None
        max_age_seconds = rospy.get_param('~max_age_seconds', None)
        if max_age_seconds:
            self.max_age = rospy.Duration.from_sec(max_age_seconds)

        self.helm_pub = rospy.Publisher('cmd_helm', Helm)
        self.wrench_pub = rospy.Publisher('cmd_wrench', Wrench)
        self.heading_pub = rospy.Publisher('cmd_course', Course)


        rospy.Subscriber("joy", Joy, self.callback)
        rospy.Subscriber("imu/data_compass", Imu, self.imu_callback) 
        rospy.spin()
   
    def output_mode(self):
        if (self.heading_hold):
            rospy.loginfo("Boat under heading hold")
            self.hold_heading = self.curr_heading
        elif (self.autonomous):
            rospy.loginfo("Boat under helm control")
        else:
            rospy.loginfo("Boat in raw R/C mode")

    def imu_callback(self,data):
        q  = data.orientation
        x,y,z = euler_from_quaternion([ getattr(q,f) for f in q.__slots__])
        self.curr_heading = z
    
    def callback(self, data):
        """ Receive joystick data, formulate Twist message. """
        #print (data.header.stamp - rospy.Time.now()).to_sec() 
        if self.max_age and data.header.stamp - rospy.Time.now() > self.max_age:
            # Joystick messages are too delayed. Discard them.
            return
        
        auto_button = data.buttons[self.autonomous_button]
        heading_button = data.buttons[self.heading_hold_button]

        #catch button transition
        if heading_button==1 and self.last_heading_button==0:
            self.heading_hold=not self.heading_hold
            self.output_mode()
        elif auto_button==1 and self.last_auto_button==0:
            self.autonomous = not self.autonomous 
            self.output_mode()
        
        self.last_auto_button = auto_button
        self.last_heading_button = heading_button


        if data.buttons[self.deadman_button] == 1 or data.buttons[self.turbo_button] == 1:

            scales = self.button_scales["turbo"] if data.buttons[self.turbo_button] == 1 else self.button_scales["deadman"]
            if data.axes[1] >= 0: #forward
                scale = scales["fwd_vel"] if self.heading_hold else scales["fwd_force"]
            else:
                scale = scales["bck_vel"] if self.heading_hold else scales["bck_force"]

            if self.heading_hold:
                cmd = YawSpd()
                cmd.yaw = self.hold_heading
                cmd.speed = data.axes[1] * scale
                self.heading_pub.publish(cmd)
            elif self.autonomous: #command closed loop yaw rate + thrust pct on helm message
                scale = 1
                cmd = Helm()
                cmd.yaw_rate = data.axes[0] * self.rotation_scale 
                cmd.thrust = data.axes[1] * scale
                self.helm_pub.publish(cmd)
            else: # command open loop thrusters on a wrench message
                cmd = Wrench()
                cmd.torque.z = data.axes[0] * self.torque_scale
                cmd.force.x = data.axes[1]  * scale
                self.wrench_pub.publish(cmd)


if __name__ == "__main__": Teleop()
